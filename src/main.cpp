#include <vector>
#include <stdio.h>
#include <fstream>
#include <iostream>
#include <algorithm>
#include <assert.h>
#include <climits>
#include <chrono>
#include "memload.h"
#include "common.h"

using namespace std;
unsigned TEXT_ADDR, TEXT_OFFSET, TEXT_SIZE;

int DEBUG;
char *image_name;

struct rel_item
{
    unsigned offset;
    unsigned len;
};

struct rel_section
{
    unsigned offset;
    unsigned size;
    int entry_size;
    int len_offset;
    int default_len;
    rel_section(unsigned os, unsigned sz, int es, int lf = -1, int dl = 0): 
        offset(os), size(sz), entry_size(es), len_offset(lf), default_len(dl){};
};

/* relocation file generated by `objdump -r elf` (obsolete)
 */
void read_relocations(vector<struct rel_item>  &relocation){
    std::ifstream infile(TEXT_REL);
    int offset;
    string type, name;
    struct rel_item item;
    while (infile >>std::hex>> offset >> type >> name){
        item.offset = offset;
        item.len = 4;
        relocation.push_back(item);
    }
}


char *get_pattern_page(char *elf_image, unsigned block_index, unsigned block_size){
    char *addr =
        (char *) ((unsigned) elf_image + TEXT_OFFSET + block_index * block_size);
    
    return addr;
}

void remove_dumplicate(vector<unsigned> &relocation){
    //remove duplicate relocation item
    int left = 0;
    int right = 0;
    for(right = 1; right < relocation.size();){
        if(relocation[right] == relocation[left]){
            right++;
        }else{
            left++;
            relocation[left] = relocation[right];
            right++;
        }
        //printf("%x\n", relocation[i]);
    }
}

bool compare_rel_item( const struct rel_item & e1, const struct rel_item& e2)
{
    return (e1.offset <= e2.offset); 
}


void parse_rel_entry(char *elf_image, vector<struct rel_item>  &relocation, 
                     struct rel_section &section){
    for(int i = 0; i < section.size; i += section.entry_size){
        struct rel_item item;
        item.offset = *((int *)(elf_image + section.offset + i)) - TEXT_ADDR; 
        if(section.len_offset < 0)
            item.len = section.default_len; 
        else
            item.len = *(elf_image + section.offset + i + section.len_offset); 
        
        assert(item.offset > 0);
        assert(item.len > 0);
        relocation.push_back(item);
    }
}

void parse_mcount_loc(char *elf_image, vector<struct rel_item>  &relocation, 
                     struct rel_section &section){
    for(int i = 0; i < section.size; i += section.entry_size){
        struct rel_item item;
        item.offset = *((int *)(elf_image + section.offset + i)) - TEXT_ADDR - 1; 
        if(section.len_offset < 0)
            item.len = section.default_len; 
        else
            item.len = *(elf_image + section.offset + i + section.len_offset); 
        
        assert(item.offset > 0);
        assert(item.len > 0);
        relocation.push_back(item);
    }
}

void parse_smp_entry(char *elf_image, vector<struct rel_item>  &relocation, 
                     struct rel_section &section){
    for(int i = 0; i < section.size; i += section.entry_size){
        struct rel_item item;
        item.offset = *((int *)(elf_image + section.offset + i)); 
        item.offset = (0xc1818000 + i) + item.offset - TEXT_ADDR;
        if(section.len_offset < 0)
            item.len = section.default_len; 
        else
            item.len = *(elf_image + section.offset + i + section.len_offset); 
        
        assert(item.offset > 0);
        assert(item.len > 0);
        relocation.push_back(item);
    }
}

void get_relocations(char * elf_image, vector<struct rel_item>  &relocation){
    vector<struct rel_section>  sections;

#ifdef LINUX2_6_30
    struct rel_section rel_text_head( 0x39e7c08, 0x1e8, 8, -1, 4);
    sections.push_back(rel_text_head);
    struct rel_section rel_text( 0x39e7df0, 0xa0b00, 8, -1, 4);
    sections.push_back(rel_text);
    struct rel_section smp_locks( 0x3eb000, 0x4ce8, 4, -1, 1);
    sections.push_back(smp_locks);
    struct rel_section altinstructions(0x44de58, 0x5213, 12, 9, 1);
    sections.push_back(altinstructions);
    struct rel_section parainstructions(0x454544, 0x3bf0, 8, 5, 1);
    sections.push_back(parainstructions);
#endif


#ifdef LINUX2_6_38_8
    struct rel_section rel_text(0x7598650, 0x152ef8, 8, -1, 4);
    sections.push_back(rel_text);
    struct rel_section altinstructions(0x806fb8, 0x63cc, 12, 10, 1);
    sections.push_back(altinstructions);
    struct rel_section parainstructions(0x7fcb10, 0xa4a8, 8, 5, 1);
    sections.push_back(parainstructions);
// struct alt_instr {
// 	u8 *instr;		/* original instruction */
// 	u8 *replacement;
// 	u16 cpuid;		/* cpuid bit set for replacement */
// 	u8  instrlen;		/* length of original instruction */
// 	u8  replacementlen;	/* length of new instruction, <= instrlen */
// #ifdef CONFIG_X86_64
// 	u32 pad2;
// #endif
// };
    struct rel_section jmp_table(0x6da108, 0x10d4, 4, -1, 4);
    sections.push_back(jmp_table);

    struct rel_section mcount_loc(0x7e4318, 0x7f9ac8 - 0x7e4318, 4, -1, 1);
    parse_mcount_loc(elf_image, relocation, mcount_loc);
#endif

    
#ifdef  LINUX3_14_8
    struct rel_section rel_text(0x6eed894, 0x1609a0, 8, -1, 4);
    sections.push_back(rel_text);
#endif
 
    for(auto & section : sections)
        parse_rel_entry(elf_image, relocation, section);
}

void scan_linux(vector<struct rel_item>  &relocation, char * elf_image, char *mem_image, unsigned mem_size){
    //page by page
    unsigned rel_index = 0;
    unsigned page_no = mem_size / PAGE_SIZE;
    for(long i = 0; i < page_no; i++){
        char *page = 
            (char *) ((unsigned) mem_image + i * PAGE_SIZE);
        char *pattern_page = get_pattern_page(elf_image, 0, PAGE_SIZE);
        long j = 0;
        rel_index = 0;
        unsigned mismatch = 0;
        for (j = 0; j < TEXT_SIZE;) {
            if(rel_index < relocation.size() && j == relocation[rel_index].offset){
                //remove relocation items
                j += relocation[rel_index].len;
                rel_index++;
                continue;
            }else if(rel_index < relocation.size() && j > relocation[rel_index].offset){
                rel_index++;
                continue;
            }else{
                if(page[j] != pattern_page[j]){
                    mismatch++;
                    if(j < 10)
                        break;
                    else
                        debug_log("Diff 0x%lx: %02hhx, %02hhx\n",
                               j, page[j], pattern_page[j]);
                }
                j++;
            }
        }

        if(j >= 10){
            printf("Successful matched sections in Memory:\n");
            printf("Page Phy addr:0x%x, All 0x%lx bytes, diff 0x%x bytes, diff ratio %f\n", 
                    page - mem_image, j, mismatch, (float)mismatch/(float)j);
            //break;
        }
    }
}

void scan_windows( vector<struct rel_item>  &relocation, char * elf_image, char *mem_image, unsigned mem_size){
    // not page by page
    unsigned rel_index = 0;
    const int BLOCK_SIZE = 0x800; //half page
    unsigned block_no = mem_size / BLOCK_SIZE;
    unsigned code_block_no = 0x1136d1/0x800;
    for(int k = 0; k < code_block_no; k++){
        for(long unsigned i = 0; i < block_no; i++){
        char *page = 
            (char *) ((unsigned) mem_image + i * BLOCK_SIZE);
        char *pattern_page = get_pattern_page(elf_image, k, BLOCK_SIZE);

        long j = 0;
        rel_index = 0;
        unsigned mismatch = 0;
        for (j = 0; j < TEXT_SIZE;) {
            if(rel_index < relocation.size() && j == relocation[rel_index].offset){
                //remove relocation items
                j +=
                rel_index++;
                continue;
            }else if(rel_index < relocation.size() && j > relocation[rel_index].offset){
                rel_index++;
                continue;
            }else{
                if(page[j] != pattern_page[j]){
                    mismatch++;
                    if(j < 100)
                        break;
                    else
                        debug_log("Diff 0x%lx 0x%lx: %02hhx, %02hhx\n",
                               i * BLOCK_SIZE + j, j, page[j], pattern_page[j]);
                }
                j++;
            }
        }

        if(j >= 10){
            /*
            printf("Successful matched sections in Memory:\n");
            printf("Offset 0x%lx, j 0x%lx, diff 0x%x, ratio %f\n", 
                   i * BLOCK_SIZE, j, mismatch, (float)mismatch/(float)j);
            */
            printf("%d: 0x%lx, ratio %f\n", k, i * BLOCK_SIZE, (float)mismatch/(float)j);

            //i += (j/ BLOCK_SIZE + 1);
             break;
        }
    }
    }
}

void reloc_scan(char *elf_image, char* mem_image, unsigned mem_size){
    std::vector<struct rel_item> relocation;
    get_relocations(elf_image, relocation);
    sort(relocation.begin(), relocation.end(), compare_rel_item);
    printf("%d location is found.\n", relocation.size());

    scan_linux(relocation, elf_image, mem_image, mem_size);
}

void all_code_scan(char *elf_image, char* mem_image, unsigned mem_size){
    const auto begin = std::chrono::high_resolution_clock::now();

    unsigned page_no = mem_size / PAGE_SIZE;
    int seq = 0;
    for(long i = 0; i < page_no; i++){
        char *page = 
            (char *) ((unsigned) mem_image + i * PAGE_SIZE);
        char *pattern_page = get_pattern_page(elf_image, 0, PAGE_SIZE);

        unsigned mismatch = 0;
        unsigned match = 0;
        for (int j = 0; j < TEXT_SIZE; j++) {
            if(page[j] != pattern_page[j]){
                mismatch++;
            }else{
                match++;
            }

            if(mismatch >= match && j > PAGE_SIZE) break;
        }

        if(mismatch < match){
            printf("%d paddr %x, total %x bytes, diff ratio %f\n", seq,
                   page - mem_image, TEXT_SIZE, (float)mismatch/TEXT_SIZE);
            write_log(seq, TEXT_SIZE, 0x1000,  (float)mismatch/TEXT_SIZE);
            seq++;
        }
    }

    auto end = chrono::high_resolution_clock::now();
    double sig_match_time = chrono::duration_cast<chrono::nanoseconds>(end-begin).count()/(double)1000000000;
    printf("match %lf\n", sig_match_time);
    write_per_log(0, sig_match_time);
}


void get_jump_table(char * image_name, unsigned &offset, unsigned &size){
    string cmd;
    cmd += "nm ";
    cmd += image_name;
    cmd += "| sort | grep -A 1 'sys_call_table' | cut -d' ' -f1 > jump_table";
    system(cmd.c_str());

    fstream infile;
    infile.open("jump_table");
    unsigned next;
    infile >> hex >> offset >> hex >> next;
    size = next - offset;
    offset = offset - TEXT_ADDR;
    infile.close();
}


void jump_table_scan(char *elf_image, char* image_name, char* mem_image, unsigned mem_size){
    const auto begin = std::chrono::high_resolution_clock::now();
    unsigned offset, size;
    get_jump_table(image_name, offset, size);
    printf("%x %x\n", offset, size);

    unsigned page_no = mem_size / PAGE_SIZE;
    int seq = 0;
    for(long i = 0; i < page_no; i++){
        char *page = 
            (char *) ((unsigned) mem_image + i * PAGE_SIZE + (offset & 0xfff));
        char *pattern_page =  (char *) ((unsigned) elf_image + offset); 

        unsigned mismatch = 0;
        unsigned match = 0;
        for (int j = 0; j < size; j++) {
            if(page[j] != pattern_page[j]){
                mismatch++;
            }else{
                match++;
            }

            if(mismatch >= match) break;
        }

        float diff_ratio =  (float)mismatch/size;
        if(mismatch < match && diff_ratio == 0 ){
            printf("%d paddr %x, total %x bytes, diff ratio %f\n", seq,
                   page - mem_image, size, diff_ratio);
            write_log(seq, size, 0x1000, diff_ratio);
            seq++;
        }
    }

    auto end = chrono::high_resolution_clock::now();
    double sig_match_time = std::chrono::duration_cast<std::chrono::nanoseconds>(end-begin).count()/(double)1000000000;
    printf("match %lf\n", sig_match_time);
    write_per_log(0, sig_match_time);
}

void get_section_info(char * image_name){
    string cmd;
    cmd += "readelf -S ";
    cmd += image_name;
    cmd += " > section_headers";
    system(cmd.c_str());
    cmd = "./get_text_section.py section_headers > text_section";
    system(cmd.c_str());

    fstream infile;
    infile.open("text_section");
    infile >> hex >> TEXT_ADDR>> hex >> TEXT_OFFSET >>hex >> TEXT_SIZE;
}

void write_log(int seq, int total, int size_page, float diff_ratio){
    ofstream log;
    log.open("log", ios::app);
    log <<seq<<"\t"<<total<<"\t"<<size_page <<"\t"<<diff_ratio<<"\t"<<(1-diff_ratio);
    log<<"\t"<<image_name<<endl;
    log.close();
}

void write_per_log(float match, float gen){
    ofstream perf_log;
    perf_log.open("perf_log", ios::app);
    perf_log<<match<<"\t"<<gen<<"\t"<<image_name<<endl;
    perf_log.close();
}

unsigned get_pgd(char *mem, int mem_size);
void call_graph_scan(char*, char *, char *, unsigned);
void rel_entry_scan(char *, char*, char *,  unsigned);
void rel_data_scan(char *, char*, char *,  unsigned);
void rel_rodata_scan(char *, char*, char *,  unsigned);
void global_data_layout_scan(char *, char *, unsigned);
void no_patch_scan(char *, char *, char *, unsigned);

int main(int argc, char *argv[]){
    DEBUG = 0; //0, disable debug log; 1, enable debug log.

    if(argc < 4){
        puts("maldives: invalid option");
        puts("usage: maldives -acrd elf_image mem_snapshot");
        return 0;
    }


    char *scan_type = argv[1];
    image_name = argv[2];
    char *mem_snapshot_name = argv[3];

    clock_t begin_time = clock();
    get_section_info(image_name);
    //1. image loading
    unsigned elf_size = 0;
    char *elf_image = mem_load(image_name, &elf_size);

    //2. memory snapshot loading
    unsigned mem_size = 0;
    char *mem_image = mem_load(mem_snapshot_name, &mem_size);

    debug_log("file load %f\n", float( clock () - begin_time ) / CLOCKS_PER_SEC);

    if(scan_type[1] == 'c')
        call_graph_scan(elf_image, image_name, mem_image, mem_size);
    else if(scan_type[1] == 'r')
        rel_entry_scan(elf_image, image_name, mem_image, mem_size);
    else if(scan_type[1] == 'a')
        all_code_scan(elf_image, mem_image, mem_size);
    else if(scan_type[1] == 'd')
        global_data_layout_scan(elf_image, mem_image, mem_size);
    else if(scan_type[1] == 'n')
        no_patch_scan(elf_image, image_name, mem_image, mem_size);
    else if(scan_type[1] == 'g')
        rel_data_scan(elf_image, image_name, mem_image, mem_size);
    else if(scan_type[1] == 'o'){
        rel_rodata_scan(elf_image, image_name, mem_image, mem_size);
    }else if(scan_type[1] == 'j')
        jump_table_scan(elf_image, image_name, mem_image, mem_size);


    /*
    //get pgd
    unsigned pgd = get_pgd(mem_filename, mem_size);
    printf("pgd %d", pgd);

    scan_windows(relocation, elf_image, mem_image, mem_size);
    */

    //4. clean up
    mem_free(elf_image);
    mem_free(mem_image);
    return 0;
}
